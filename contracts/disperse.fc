;; Disperse: Being able to send TON to multiples wallets at the same time using an smart contract BUT ALSO jetton tokens. I can also select % instead of amount.
;; Collect: Being able to collect TON from multiples at the same time and send just to one wallet using an smart contrct but ALSO Jeton tokens using % of the wallet. This should be developed in Rust

#include "imports/stdlib.fc";

const int op::deploy = 0;
const op::add_wallet = "op::add_wallet"c;
const op::add_jetton_wallet = "op::add_jetton_wallet"c;
const op::transfer = "op::transfer"c;
const op::transfer_jetton = "op::transfer_jetton"c;

global slice sender_address;
global cell addr_dict;

global slice ctx_owner_addr;
global cell ctx_src_jetton_wallet_addr_dict;
global cell ctx_dest_wallet_addr_dict;

() save_data() impure inline {
    ~strdump("Start save_data()");
    addr_dict = new_dict();
    ~strdump("sd_check");
    addr_dict~udict_set(32, 0, begin_cell().store_dict(ctx_src_jetton_wallet_addr_dict).end_cell().begin_parse());
    addr_dict~udict_set(32, 1, begin_cell().store_dict(ctx_dest_wallet_addr_dict).end_cell().begin_parse());
    ~strdump("sd_check");
    set_data(
        begin_cell()
            .store_slice(ctx_owner_addr)
            .store_dict(addr_dict)
        .end_cell()
    );
    ~strdump("End save_data()");
}

() load_data() impure {
    ~strdump("check");
    slice ds = get_data().begin_parse();
    ctx_owner_addr = ds~load_msg_addr();
    ~strdump("check");
    addr_dict = ds~load_dict();
    ~strdump("check");
    (slice ctx_src_jetton_wallet_addr_dict_cs, int f0) = addr_dict.udict_get?(32, 0);
    ctx_src_jetton_wallet_addr_dict = ctx_src_jetton_wallet_addr_dict_cs~load_dict();
    ~strdump("check");
    (slice ctx_dest_wallet_addr_dict_cs, int f1) = addr_dict.udict_get?(32, 1);
    ctx_dest_wallet_addr_dict = ctx_dest_wallet_addr_dict_cs~load_dict();
    ~strdump("check");
    ds.end_parse();
    ~strdump("check");
}

() main(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ~strdump("1");
    ~strdump("1");
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }
    ~strdump("1");
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    sender_address = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    if (op == op::deploy) {
        slice ds = get_data().begin_parse();
        if (ds.slice_empty?()) { ;; on deploy
            ~strdump("check1");
            ctx_owner_addr = sender_address;
            ~strdump("check1");
            ctx_src_jetton_wallet_addr_dict = new_dict();
            ~strdump("check1");
            ctx_dest_wallet_addr_dict = new_dict();
            ~strdump("check1");
            save_data();
        }
    }
    ~strdump("1");
    ;; owner_check
    ~strdump("1");
    load_data(); ;; here we populate the storage variables
    ~strdump("1");
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case
    ~strdump("1");
    if (op == op::add_wallet) {
        ~strdump("1");
        slice new_wallet_addr = in_msg_body~load_msg_addr();
        ~strdump("1");
        (int key, _, int success?) = ctx_dest_wallet_addr_dict.udict_get_max?(32);
        ctx_dest_wallet_addr_dict.udict_add?(32, key, new_wallet_addr);
            ~strdump("1");
        save_data();
        return ();
    }
    if (op == op::add_jetton_wallet) {
        
        save_data();
        return ();
    }
}

slice get_owner_addr() method_id {
    load_data();
    return ctx_owner_addr;
}

cell get_wallets() method_id {
    load_data();
    return ctx_dest_wallet_addr_dict;
}
